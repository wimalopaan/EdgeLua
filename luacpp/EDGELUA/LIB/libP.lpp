--
-- EdgeLUA - EdgeTx / OpenTx Extensions 
-- Copyright (C) 2021 Wilhelm Meier <wilhelm.wm.meier@googlemail.com>
--
-- This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License. 
-- To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/ 
-- or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.

-- IMPORTANT
-- Please note that the above license also covers the transfer protocol used and the encoding scheme and 
-- all further principals of tranferring state and other information.

#include "../../global.h"

local Class = {};

function Class.new(prototype)
  local o = {};
  setmetatable(o, prototype);
  prototype.__index = prototype;
  return o;
end

local Queue = {first = 0, last = -1};

function Queue:new()
  return Class.new(Queue);
end
function Queue:push (item)
  self.last = self.last + 1;
  self[self.last] = item;
end
function Queue:pop()
  local item = self[self.first];
  self[self.first] = nil;
  self.first = self.first + 1;
  return item;
end
function Queue:size()
  return self.last - self.first + 1;
end

Class.Queue = Queue;

local function nextItem(menu, state)
  local page = menu[state[FSMSWITCH_CyclePage]];
  if (state[FSMSWITCH_CycleRow] == #page) then
    state[FSMSWITCH_CycleRow] = 1;
    if (state[FSMSWITCH_CyclePage] == #menu) then
      state[FSMSWITCH_CyclePage] = 1;
    else
      state[FSMSWITCH_CyclePage] = state[FSMSWITCH_CyclePage] + 1;
    end
  else
    state[FSMSWITCH_CycleRow] = state[FSMSWITCH_CycleRow] + 1;
  end
end

local function setSwitchOn(lsNumber) 
  local max = getFieldInfo("max");
  if (max) then
    local maxId = max.id;
    local ls = model.getLogicalSwitch(lsNumber);
    ls.func = 3;
    model.setLogicalSwitch(lsNumber, ls); 
  end 
end  

local function setSwitchOff(lsNumber) 
  local max = getFieldInfo("max");
  if (max) then
    local maxId = max.id;
    local ls = model.getLogicalSwitch(lsNumber);
    ls.func = 1;
    model.setLogicalSwitch(lsNumber, ls); 
  end 
end 

local function rssiState(cfg, state)
  if (cfg[CFG_SafeMode_LsNumber]) then
    local t = getTime();

    if not(state[FSMRSSI_State]) then
      state[FSMRSSI_State] = 0;
      state[FSMRSSI_LastTime] = t;
      setSwitchOff(cfg[CFG_SafeMode_LsNumber]);
    end 
    if (state[FSMRSSI_State] == FSMRSSI_STATE_SafeMode) then -- safeMode
      if (getRSSI() > 10) then
        TRACE("safemode: on");
        state[FSMRSSI_State] = FSMRSSI_STATE_WaitUp;
        state[FSMRSSI_LastTime] = t;
      end 
    elseif (state[FSMRSSI_State] == FSMRSSI_STATE_WaitUp) then -- wait rssi
      if (getRSSI() < 10) then
        TRACE("safemode: wait up: down");
        state[FSMRSSI_LastTime] = t;
        state[FSMRSSI_State] = FSMRSSI_STATE_SafeMode;
      end 
      if ((t - state[FSMRSSI_LastTime]) > cfg[CFG_SafeMode_Timeout]) then
        setSwitchOn(cfg[CFG_SafeMode_LsNumber]);
        TRACE("safemode: wait up: up");
        state[FSMRSSI_LastTime] = t;
        state[FSMRSSI_State] = FSMRSSI_STATE_Normal;
      end
    elseif (state[FSMRSSI_State] == FSMRSSI_STATE_Normal) then -- normal
      if (getRSSI() < 10) then
        TRACE("safemode normal: down");
        state[FSMRSSI_LastTime] = t;
        state[FSMRSSI_State] = FSMRSSI_STATE_WaitDown;
      end 
    elseif (state[FSMRSSI_State] == FSMRSSI_STATE_WaitDown) then -- wait normal
      if (getRSSI() > 10) then
        TRACE("safemode: wait down: up");
        state[FSMRSSI_LastTime] = t;
        state[FSMRSSI_State] = FSMRSSI_STATE_Normal;
      end 
      if ((t - state[FSMRSSI_LastTime]) > cfg[CFG_SafeMode_LinkDropoutMax]) then
        setSwitchOff(cfg[CFG_SafeMode_LsNumber]);
        TRACE("safemode: wait down: down");
        state[FSMRSSI_LastTime] = t;
        state[FSMRSSI_State] = FSMRSSI_STATE_SafeMode;
      end
    end
  end 
end

local function sportConfigFSM()
end

local function sbusConfigFSM(config, menu, headers, menuState, queue, state, encoder, paramEncoder, pValue)
  local t = getTime();
  if ((t - state[FSMCONF_LastTime]) > config[CFG_StateTimeout]) then
    if (state[FSMCONF_State] == FSMCONF_STATE_Wait) then
      if (queue:size() > 0) then
        state[FSMCONF_Row] = queue:pop(); -- line
        TRACE("cFSM: ", state[FSMCONF_State], state[FSMCONF_Row][PLINE_Item][PITEM_Name]);
        state[FSMCONF_State] = FSMCONF_STATE_BCastOff;
        state[FSMCONF_LastTime] = t;
        paramEncoder(config[CFG_MixerGlobalVariable], 31, 31); -- bcast off (handles sbus correct)
      end
    elseif (state[FSMCONF_State] == FSMCONF_STATE_BCastOff) then -- broadcast off
      TRACE("cFSM: ", state[FSMCONF_State]);
      if ((t - state[FSMCONF_LastTime]) > 50) then
        state[FSMCONF_State] = FSMCONF_STATE_SelectOn;
        state[FSMCONF_LastTime] = t;
--        local item = {[3] = 2, [4] = state[3][1][2], [5]  = state[3][1][3]};
        local item = {
          [ITEM_State] = 2, -- state = on
          [ITEM_Function] = state[FSMCONF_Row][PLINE_Item][PITEM_Function],
          [ITEM_Module] = state[FSMCONF_Row][PLINE_Item][PITEM_Module]
        }
        encoder(config[CFG_MixerGlobalVariable], item); -- set laston in module
      end
    elseif (state[FSMCONF_State] == FSMCONF_STATE_SelectOn) then -- select item
      TRACE("cFSM: ", state[FSMCONF_State]);
      if ((t - state[FSMCONF_LastTime]) > 50) then
        state[FSMCONF_State] = FSMCONF_STATE_SendValue;
        state[FSMCONF_LastTime] = t;
      end
    elseif (state[FSMCONF_State] == FSMCONF_STATE_SendValue) then -- send pvalue
      if (menuState[MENUSTATE_SelRow] == 0) and (menuState[MENUSTATE_SelCol] == 0) then
        state[FSMCONF_State] = FSMCONF_STATE_End;
        state[FSMCONF_LastTime] = t;
      else
        local item = state[FSMCONF_Row][PLINE_Item];
        local values = state[FSMCONF_Row][PLINE_Values];
        local col = menuState[MENUSTATE_SelCol];
        local value = values[col];
        local itemLine = state[FSMCONF_Row][PLINE_Line];
        local pageHeaders = headers[ menuState[MENUSTATE_Page] ];
        local header = pageHeaders[itemLine + PHEADER_LinesStart - 1];
        local paramNumber = header[col][PHITEM_ParamId];
        TRACE("cFSM: ", state[FSMCONF_State], "P:", paramNumber, "V:", value, header);
        paramEncoder(config[CFG_MixerGlobalVariable], paramNumber, value);
      end
    elseif (state[FSMCONF_State] == FSMCONF_STATE_End) then -- end
      TRACE("cFSM: ", state[FSMCONF_State]);
      state[FSMCONF_State] = FSMCONF_STATE_Wait;
      state[FSMSWITCH_LastTime] = t;
    end     
  end
end

local function sportSwitchFSM()
end

local function tiptipSwitchFSM()
end

local function sbusSwitchFSM(config, menu, queue, state, encoder, exportValues)
  local t = getTime();
  if ((t - state[FSMSWITCH_LastTime]) > config[CFG_StateTimeout]) then
    local item = nil;
    if (queue:size() > 0) then
      item = queue:pop();
    else
      local page = menu[state[FSMSWITCH_CyclePage]]; 
      item = page[state[FSMSWITCH_CycleRow]]; 
      if (item[ITEM_Virtual]) then -- virtuals are not cyclic pushed
        item = nil;
      end 
      nextItem(menu, state);
    end
    if (item) then
      if (item[ITEM_Virtual]) then
        for i, virt in ipairs(item[ITEM_Virtual]) do
          virt[ITEM_State] = item[ITEM_State];
          queue:push(virt);
        end
      else
        encoder(config[CFG_MixerGlobalVariable], item);
        if (item[ITEM_Export]) then -- export
          local expValue = exportValues[ item[ITEM_State] ] * 1024 / 100;
          model.setGlobalVariable(item[ITEM_Export], 0, expValue);
        end
      end
      state[FSMSWITCH_LastTime] = t;
    end 
  end
end

local function setXJT(gv, sbusValue)
  local b = bit32.extract(sbusValue, 4);
  if (sbusValue >= 0) then
    model.setGlobalVariable(gv, 0, (sbusValue * 1024) / 1638 + 0.5);
  else
    if (b == 0) then
      model.setGlobalVariable(gv, 0, (sbusValue * 1024) / 1638 - 0.5);
    else
      model.setGlobalVariable(gv, 0, (sbusValue * 1024) / 1638 + 0.5);
    end
  end
end 

local function setIBus(gv, ibusValue)
  if (ibusValue >= 0) then
    model.setGlobalVariable(gv, 0, ibusValue + 1);
  else
    model.setGlobalVariable(gv, 0, ibusValue);
  end
end 

local function setSBus(gv, sbusValue)
  if (sbusValue >= 0) then
    model.setGlobalVariable(gv, 0, (sbusValue * 1024) / 1638 + 1.5);
  else
    model.setGlobalVariable(gv, 0, (sbusValue * 1024) / 1638 + 0.5);
  end   
end 

local function parameterToValueSBus(paramNumber, paramValue)
  if (paramNumber >= 0) and (paramNumber <= 15) then
    if (paramValue >= 0) then
      if (paramValue > 15) then
        paramValue = 15;
      end 
      return (512 + paramNumber * 32 + 2 * paramValue) * 2 - 1024;
    end
  end
  return 0;
end 

local function parameterToValueIBus(paramNumber, paramValue)
  if (paramNumber >= 0) and (paramNumber <= 15) then
    if (paramValue >= 0) then
      if (paramValue > 31) then
        paramValue = 31;
      end 
      return (512 + paramNumber * 32 + paramValue) * 2 - 1024;
    end
  end
  return 0;
end 

local function encodeParamXJT(gv, paramNumber, paramValue)
  local sbusValue = parameterToValueSBus(paramNumber, paramValue);
  setXJT(gv, sbusValue);
end 

local function encodeParamIBus(gv, paramNumber, paramValue)
  local ibusValue = parameterToValueIBus(paramNumber, paramValue);
  setIBus(gv, ibusValue);
end 

local function encodeParamSBus(gv, paramNumber, paramValue)
  local sbusValue = parameterToValueSBus(paramNumber, paramValue);
  setSBus(gv, sbusValue);
end 

local function encodeXJT(gv, item)
  local state = item[ITEM_State];
  local fn = item[ITEM_Function];;
  local module = item[ITEM_Module];
--   print("xjt: ", item[ITEM_Name], module, fn, state);

  local sbusValue = (64 * (module - 1) + 8 * (fn - 1) +  2 * (state - 1)) * 2 - 1024;
  setXJT(gv, sbusValue);
end

local function encodeSBus(gv, item)
  local state = item[ITEM_State];
  local fn = item[ITEM_Function];
  local module = item[ITEM_Module];
  --print("sbus: ", module, fn, state);

  local sbusValue = (64 * (module - 1) + 8 * (fn - 1) +  2 * (state - 1)) * 2 - 1024;
  setSBus(gv, sbusValue);
end

local function encodeIBus(gv, item)
  local state = item[ITEM_State];
  local fn = item[ITEM_Function];
  local module = item[ITEM_Module];
--   print("ibus: ", module, fn, state);

  local ibusValue = (64 * (module - 1) + 8 * (fn - 1) + (state - 1)) * 2 - 1024;
  setIBus(gv, ibusValue);
end

local function percentOf(v)
  return math.floor((v + 1024) / 20.48);
end

local function parameterValueIbus(config)
  local v = getValue(config[CFG_ParamaterDialId]);
  local s = ((v + 1024) * 32) / 2048;
  if (s > 31) then
    s = 31;
  elseif (s < 0) then
    s = 0;
  end
  return math.floor(s), percentOf(v);
end

-- use half the range
local function parameterValueSbus(config)
  local v = getValue(config[CFG_ParamaterDialId]);
  local s = ((v + 1024) * 16) / 2048;
  if (s > 15) then
    s = 15;
  elseif (s < 0) then
    s = 0;
  end
  return math.floor(s), percentOf(v);
end

local function encodeSPort(gv, item)
end

local function encodeTipTip(gv, item)
end

local function getEncoder(cfg)
  if not(cfg[CFG_Backend]) or (cfg[CFG_Backend] <= 1) then 
    local type = cfg[CFG_Encoding];
    if (type == 0) then
      return encodeXJT, parameterValueSbus, encodeParamXJT;
    elseif (type == 1) then
      return encodeIBus, parameterValueIbus, encodeParamIBus;
    elseif (type == 2) then
      return encodeSBus, parameterValueSbus, encodeParamSBus;
    end
    return encodeSBus, parameterValueSbus, encodeParamSBus;
  else
    if (cfg[CFG_Backend] == 2) then
      return encodeSPort, parameterValueSPort, encodeParamSPort;
    elseif (cfg[CFG_Backend] == 3) then
      return encodeTipTip;
    end
  end
end

local function getConfigFSM(cfg)
  if (cfg[CFG_Backend] <= 1) then
    return sbusConfigFSM;
  elseif (cfg[CFG_Backend] == 2) then
    return sportConfigFSM;
  else
    return function() end;
  end
end

local function getSwitchFSM(cfg)
  if (cfg[CFG_Backend] <= 1) then
    return sbusSwitchFSM;
  elseif (cfg[CFG_Backend] == 2) then
    return sportSwitchFSM;
  else
    return tiptipSwitchFSM;
  end
end

return {
  Class = Class,
  getSwitchFSM = getSwitchFSM,
  getConfigFSM = getConfigFSM,
  getEncoder = getEncoder,
  rssiState = rssiState,
};
