--
-- EdgeLUA - EdgeTx / OpenTx Extensions 
-- Copyright (C) 2021 Wilhelm Meier <wilhelm.wm.meier@googlemail.com>
--
-- This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License. 
-- To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/ 
-- or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.

-- IMPORTANT
-- Please note that the above license also covers the transfer protocol used and the encoding scheme and 
-- all further principals of tranferring state and other information.

#include "../../global.h"

local function isEdgeTx()
  local ver, radio, maj, minor, rev, osname = getVersion();
  return osname ~= nil;
end

local function initWidgetBW()
  local widget = {0, 0, 0, 0, 0, 0, 0};
  widget[W_X] = 0;
  widget[W_Y] = 0;
  widget[W_Width] = LCD_W;
  widget[W_Height] = LCD_H;
  widget[W_FontHeight] = 8;
  widget[W_YOffset] = 8;
  widget[W_YPOffset] = 16;
  return widget;
end

local function initWidgetColor()
  local widget = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  widget[W_X] = 0;
  widget[W_Y] = 0;
  widget[W_Width] = LCD_W;
  widget[W_Height] = LCD_H;

  if (isEdgeTx()) then
    local w, h = lcd.sizeText("A", SMLSIZE); 
    widget[W_FontHeight] = h - 1;
    widget[W_FontHSmall] = h;
    widget[W_FontHLarge] = h * 3 / 2;
    w, h = lcd.sizeText("A", MIDSIZE); 
    widget[W_YOffset] = h;
    widget[W_YPOffset] = h;
  else
    widget[W_FontHeight] = 16;
    widget[W_FontHSmall] = 16;
    widget[W_FontHLarge] = 32;
    widget[W_YOffset] = 16;
    widget[W_YPOffset] = 32;
  end
  return widget;
end

local function getLogicalSwitchFor(id)
  local max = getFieldInfo("max");
  if not(max) then return -1; end

  local maxId = max.id;
  for lsNumber = 63, 0, -1 do
    local ls = model.getLogicalSwitch(lsNumber);
    if (ls) then
      if (ls.func == LSFUNC_A_GT_X) and (ls.v1 == maxId) and (ls.v2 == 0) and (ls["and"] == id) then
        return lsNumber;
      end
    end
  end
  return -1;
end

local function getFirstFreeLogicalSwitch()
  for lsNumber = 63, 0, -1 do
    local ls = model.getLogicalSwitch(lsNumber);
    if (ls) and (ls.func == 0) then
      return lsNumber;
    end
  end
  return -1;
end

local function insertLogicalSwitchFor(id)
  TRACE("insertLogicalSwitchFor", id);

  #ifdef USE_TRIM_NAMES
  if (type(id) == "string") then
    local swinfo = getFieldInfo(id);
    if (swinfo) then
      TRACE("insertLogicalSwitchFor swinfo", id, swinfo.id);
      id = swinfo.id;
    end
  end
  #endif

  local max = getFieldInfo("max");
  if (max) then
    local maxId = max.id;
    if (id) then
      local lsNumber = getLogicalSwitchFor(id); 
      if (lsNumber < 0) then
        lsNumber = getFirstFreeLogicalSwitch();
        if (lsNumber >= 0) then
          model.setLogicalSwitch(lsNumber, {func = LSFUNC_A_GT_X, v1 = maxId, v2 = 0, ["and"] = id});
        end
      end
      if (lsNumber >= 0) then
        local lsf = getFieldInfo("ls" .. (lsNumber + 1));
        if (lsf) then
          TRACE("insertLogicalSwitchFor", lsNumber, lsf.id)
          return lsf.id;
        end
      end
    end
  end
  return -1;
end 

local function insertSettableSwitch(number)
  TRACE("insertSettableSwitch");
  local max = getFieldInfo("max");
  if (max) then
    local maxId = max.id;

    for n = 63, 0, -1 do
      local ls = model.getLogicalSwitch(n);
      if ((ls.func == LSFUNC_A_EQ_X) or (ls.func == LSFUNC_A_GT_X)) and (ls.v1 == maxId) and (ls.v2 == number) then
        return n;
      end
    end 
    local lsNumber = getFirstFreeLogicalSwitch();
    if (lsNumber >= 0) then
      model.setLogicalSwitch(lsNumber, {func = LSFUNC_A_EQ_X, v1 = maxId, v2 = number}); -- func: 1: a == 0, 3: a > x 
      return lsNumber;
    end 
  end 
  return -1;
end 


local function loadFile(baseDir)
  local content = nil;
  local filename = nil;
  if (#model.getInfo().name > 0) then
    filename = model.getInfo().name .. ".lua";
    TRACE("loadFile", baseDir .. filename);
    content = loadScript(baseDir .. filename);      
  end
  if not content then
    if (LCD_W <= 128) then
      filename = "tiny.lua";
      TRACE("loadFile", baseDir .. filename);
      content = loadScript(baseDir .. filename);
    elseif (LCD_W <= 212) then
      filename = "medium.lua";
      TRACE("loadFile", baseDir .. filename);
      content = loadScript(baseDir .. filename);
    else
      filename = "large.lua";
      TRACE("loadFile", baseDir .. filename);
      content = loadScript(baseDir .. filename);
    end
  end
  return content, filename;
end

local function loadMenu()
  local baseDir = BASE_DIR .. "/MODELS/";
  local menu, filename = loadFile(baseDir);
  TRACE("loadMenu:", menu, filename);
  if (menu) then
    local modchunk = loadScript(BASE_DIR .. "/COMMON/swmods.lua");
    if (modchunk) then
      local modules = modchunk();
      if (modules) then
        local m, map, exportValues = menu();
        return m, exportValues, filename, map, modules;
      end
    end
  end
  return nil;
end

local function loadConfig()
  local baseDir = BASE_DIR .. "/RADIO/";
  local cfg = loadFile(baseDir);
  TRACE("loadCOnfig", cfg);
  if (cfg) then
    return cfg();
  end
  return nil;
end

local function initConfigBW(config)
  TRACE("initConfigBW");
  local cfg = {};
  if (config.title) then
    cfg[CFG_Title] = config.title;
  else
    cfg[CFG_Title] = "WmSw";
  end
  if (config.firstColumnWidth) then
    cfg[CFG_FirstColWidth] = config.firstColumnWidth;
  else
    cfg[CFG_FirstColWidth] = 40;
  end
  if (config.stateTimeout) then
    cfg[CFG_StateTimeout] = config.stateTimeout;
  else
    cfg[CFG_StateTimeout] = 20;
  end

  if (config.parameterDial) then
    local info = getFieldInfo(config.parameterDial);
    if (info) then
      cfg[CFG_ParamaterDialId] = info.id;
    end
  end

  local module = model.getModule(config.module or 0);

  if not(module) or (module.Type == 0) then
    module = model.getModule(1);
  end

  if (module) then
    local type = module.Type;
    local proto = module.protocol;
    local subproto = module.subProtocol;
    --print("gc m: ", type, proto, subproto);
    if (type == 2) then -- xjt
      cfg[CFG_Encoding] = 0; -- xjt
    elseif (type == 6) then -- mpm
      if (proto == 28) then -- AFHDS2A
        cfg[CFG_Encoding] = 1; -- ibus
      else
        cfg[CFG_Encoding] = 2; -- sbus
      end
    else
      cfg[CFG_Encoding] = 2; --sbus
    end
  else
    cfg[CFG_Encoding] = 2; --sbus
  end

  if (config.mixerGlobalVariable >= 1) then
    cfg[CFG_MixerGlobalVariable] = config.mixerGlobalVariable - 1;
  else
    cfg[CFG_MixerGlobalVariable] = 5; -- GV6
  end

  if (config.backend >= 1) and (config.backend <= 3) then
    cfg[CFG_Backend] = config.backend;
  else  
    cfg[CFG_Backend] = 1;
  end 

--  model.deleteMixes();

  if (config.safeMode) then
    if (config.safeMode.flightMode > 0) then
      if (config.safeMode.timeOut > 0) and (config.safeMode.linkDropoutMax > 0) then
        local fmLsNumber = insertSettableSwitch(1);
        if (fmLsNumber >= 0) then
          TRACE("safemode ls number", fmLsNumber)
          for ch = 0,63 do
            local lines = model.getMixesCount(ch);
            for line = 0, lines do
              local m = model.getMix(ch, line);
              if (m) then
                if not(string.find(m.name, "sw")) then
                  local mask = bit32.lshift(1, config.safeMode.flightMode);
                  m.flightModes = bit32.bor(m.flightModes, mask);
                  model.deleteMix(ch, line);
                  model.insertMix(ch, line, m);
                end 
              end
            end 
          end
          local fm = model.getFlightMode(config.safeMode.flightMode);
          if (fm) then
            #ifdef USE_TRIM_NAMES
              local ls = getFieldInfo("sl" .. (fmLsNumber + 1)); -- patch: ls switch id from name          
              if (ls) then
                if (config.safeMode.name) then
                  fm.name = config.safeMode.name;
                else
                  fm.name = "SafeMode";
                end
                TRACE("safeMode ls.id", ls.id);
                fm.switch = -ls.id; -- inverted
                model.setFlightMode(config.safeMode.flightMode, fm);
              end
            #else
              if (config.safeMode.name) then
                fm.name = config.safeMode.name;
              else
                fm.name = "SafeMode";
              end
              TRACE("safeMode !LS63";
              fm.switch = -136; -- inverted LS63
              model.setFlightMode(config.safeMode.flightMode, fm);
              #endif
          end 
          cfg[CFG_SafeMode_FlightMode] = config.safeMode.flightMode;
          cfg[CFG_SafeMode_Timeout] = config.safeMode.timeOut * 100;
          cfg[CFG_SafeMode_LinkDropoutMax] = config.safeMode.linkDropoutMax * 100;
          cfg[CFG_SafeMode_LsNumber] = fmLsNumber;
        end 
      end 
    end 
  end

  return cfg;
end

local function initConfigColor(config)
  TRACE("initConfigColor");
  local cfg = initConfigBW(config);

  local info = {};
  if (config.scrollUpDn) then
    info = getFieldInfo(config.scrollUpDn);
    if (info) then
      cfg[CFG_ScrollUdId] = info.id;
    end
  end
  if (config.scrollLR) then
    info = getFieldInfo(config.scrollLR);
    if (info) then
      cfg[CFG_ScrollLrId] = info.id;
    end
  end
  if (config.pageSwitch) then
    info = getFieldInfo(config.pageSwitch);
    if (info) then
      cfg[CFG_PageSwitchId] = info.id;
    end
  end
  if (config.remote) then
    info = getFieldInfo(config.remote);
    if (info) then
      cfg[CFG_RemoteId] = info.id;
    end
  end

  local footer = "Vers: " .. VERSION;
  if (cfg[CFG_Encoding] == 0) then
    footer = footer .. " Mod: xjt";
  elseif (cfg[CFG_Encoding] == 1) then
    footer = footer .. " Mod: ibus";
  else
    footer = footer .. " Mod: sbus";
  end
  cfg[CFG_Footer] = footer;

  if (config.title) then
    footer = footer .. " Conf: " .. config.title;
  end

  local lsfId = insertLogicalSwitchFor(config.previous);
  if (lsfId >= 0) then
    cfg[CFG_PreviousLsId] = lsfId;
  end 
  lsfId = insertLogicalSwitchFor(config.next);
  if (lsfId >= 0) then
    cfg[CFG_NextLsId] = lsfId;
  end 
  lsfId = insertLogicalSwitchFor(config.select);
  if (lsfId >= 0) then
    cfg[CFG_SelectLsId] = lsfId;
  end 

  if (config.removeTrimsFromFlightModes) then
    for mi, modeline in ipairs(config.removeTrimsFromFlightModes) do
      local mode = modeline.mode;
      TRACE("Mode:", mode);
      local fm = model.getFlightMode(mode);      
      if (fm) and (modeline.trims) then
        local tmodes = {0, 0, 0, 0, 0, 0};
        --[[
        for k, v in pairs(fm.trimsModes) do
          print("t:", k, v);
          tmodes[k + 1] = v;
        end 
        ]]
        for itr, tr in ipairs(modeline.trims) do
          TRACE("Disable Trim:", itr, tr);
          tmodes[tr] = TRIMS_MODE_DISABLE_TRIM; -- disable
        end
        fm.trimsModes = tmodes;
        model.setFlightMode(mode, fm);
      end
    end 
  end 
  return cfg;
end

local function findItem(cmenu, fn, module) -- compressed-menu
  for ip, page in ipairs(cmenu) do
    for i, item in ipairs(page) do
      if (item[ITEM_Function]) and (item[ITEM_Module]) and (item[ITEM_Function] == fn) and (item[ITEM_Module] == module) then
        return item;
      end
    end
  end
  return nil;
end

local function findModuleInfo(module, map, modInfos)
  for imap, entry in ipairs(map) do
    if (entry.module == module) then
      for imod, modInfo in ipairs(modInfos) do
        if (entry.type == modInfo.type) then
          if (entry.description) then
            modInfo.help = entry.description;
          end
          if (entry.saveparams) then
            modInfo.save = true;
          end
          return modInfo;
        end
      end
    end
  end
  return nil;
end

local function getModules(map)
  local modules = {};
  for i, mod in ipairs(map) do
    modules[i] = mod.module;
  end
  return modules;
end

local function moduleItems(menu) 
  local mi = {};
  for ip, page in ipairs(menu) do
    for ii, item in ipairs(page) do
      if (item.module) and (item.fn) and (item.module > 0) and (item.fn > 0) then
        if not(mi[item.module]) then
          mi[item.module] = {};
        end
        mi[item.module][#mi[item.module] + 1] = item;
      end
    end
  end
  return mi;
end

local function initParamMenu(cfg, menu, map, modInfos, mode)
  if not(menu) or not(map) or not(modInfos) then
    return;
  end

  local cmenu = {};
  local headers = {};
  local help = {};
  local modulesToSave = {};

  local miTable = moduleItems(menu);

  for _, imodule in ipairs(getModules(map)) do
    local items = miTable[imodule];
    if (#items > 0) then
      local modInfo = findModuleInfo(imodule, map, modInfos); -- full module info table 
      if (modInfo) then
        if (modInfo.save) then
          TRACE("initParamMenu save module", imodule);
          modulesToSave[imodule] = true;
        end
        local header = {nil, nil, nil}; -- header[1] = title, header[2] =  moduleNumber
        header[PHEADER_Title] = modInfo.description;
        header[PHEADER_Module] = imodule;
        header[PHEADER_LinesStart] = nil;
        for l, hline in ipairs(modInfo.moduleParams) do -- header[3...] = {{shortName, pId}, ...}
          local line = {};
          for ip, param in ipairs(hline) do
            if (mode) then
              line[ip] = {param[1], param[3]}; -- long label
            else
              line[ip] = {param[2], param[3]}; -- short label
            end
          end
          header[(l - 1) + PHEADER_LinesStart] = line;
        end        

        local page = {};
        local citem = {nil, nil, nil}; -- {name, fn, module}, Dummy Eintrag um ein lastOn im Modul auszulÃ¶sen
        citem[PITEM_Name] = "Module";
        citem[PITEM_Function] = 1;
        citem[PITEM_Module] = imodule;
        for itemLineNumber = 1, #modInfo.moduleParams do
          local line = {nil, nil, nil}; -- {citem, {v0, v1, v2, ...}, itemLine}
          local values = {};
          for valueNumber = 1, #modInfo.moduleParams[itemLineNumber] do
            values[valueNumber] = 0;
          end
          line[PLINE_Item] = citem;
          line[PLINE_Values] = values;
          line[PLINE_Line] = itemLineNumber;
          page[#page + 1] = line;
        end
        headers[#headers + 1] = header;
        cmenu[#cmenu + 1] = page;
        if (mode) and (modInfo.help) then
          help[#cmenu] = modInfo.help;
        end

        header = {nil, nil, nil}; -- header[1] = title, header[2] =  moduleNumber
        header[PHEADER_Title] = modInfo.description;
        header[PHEADER_Module] = imodule;
        header[PHEADER_LinesStart] = nil;
        for l, hline in ipairs(modInfo.functionParams) do -- header[3...] = {{shortName, pId}, ...}
          local line = {};
          for ip, param in ipairs(hline) do
            if (mode) then
              line[ip] = {param[1], param[3]}; -- long label
            else
              line[ip] = {param[2], param[3]}; -- short label
            end
          end
          header[(l - 1) + PHEADER_LinesStart] = line;
        end

        local maxItemLines = 8 - #header; -- possible lines usable for function-parameters
        local itemsPerPage = math.floor(maxItemLines / #modInfo.functionParams);
        local pages = math.ceil(#items / itemsPerPage); -- needed for this module

        local itemNumber = 1;
        for p = 1, pages do
          local page = {};
          for inlineNumber = 1, itemsPerPage do
            local item = items[itemNumber];
            if (item) then
              local citem = {nil, nil, nil}; -- {name, fn, module}
              citem[PITEM_Name] = item[1];
              citem[PITEM_Function] = itemNumber;
              citem[PITEM_Module] = imodule;
              for itemLineNumber = 1, #modInfo.functionParams do
                local line = {nil, nil, nil}; -- {citem, {v0, v1, v2, ...}, itemLine}
                local values = {};
                if (modulesToSave[imodule]) then
                  TRACE("initParamMenu: load Values", imodule, itemNumber, #modInfo.functionParams[itemLineNumber]);
                end
                for valueNumber = 1, #modInfo.functionParams[itemLineNumber] do
                  values[valueNumber] = 0;
                end
                line[PLINE_Item] = citem;
                line[PLINE_Values] = values;
                line[PLINE_Line] = itemLineNumber;
                page[#page + 1] = line;
              end
            else
              break;
            end
            itemNumber = itemNumber + 1;
          end
          cmenu[#cmenu + 1] = page;
          headers[#headers + 1] = header;
          if (mode) and (modInfo.help) then
            help[#cmenu] = modInfo.help;
          end
        end	    
      end
    end
  end
  return headers, cmenu, help, modulesToSave;
end

local function initParamMenuBW(cfg, menu, map, modInfos)
  return initParamMenu(cfg, menu, map, modInfos, false);
end

local function initParamMenuColor(cfg, menu, map, modInfos, filename)
  if not(menu) or not(map) or not(modInfos) then
    return;
  end
  local headers, cmenu, help, modulesToSave = initParamMenu(cfg, menu, map, modInfos, true);

  if (cfg[CFG_Footer]) then
    cmenu.footer = cfg[CFG_Footer];
    if (filename) then
      cmenu.footer = cmenu.footer .. " File:" .. filename;
    end
  end
  return headers, cmenu, help, modulesToSave;
end

local function initMenuBW(menu)
  if not menu then
    return;
  end

  local cmenu = {};
  local shortCuts = {};
  local overlays = {};
  local pagetitles = {};

  for i, p in ipairs(menu) do
    overlays[i] = {};
  end
  local switchUse = {};

  local switchId = nil; 
  local lsmode = 0;
  for i, p in ipairs(menu) do
    if (p.title) then
      pagetitles[i] = p.title;
    end
    cmenu[i] = {};
    for k, item in ipairs(p) do
      switchId = nil;
      lsmode = 0;
      if (item.switch) then
        local s = getFieldInfo(item.switch);
        if (s) then
          switchId = s.id;
        end
        if (string.find(item.switch, "ls")) then
          lsmode = item.lsmode;
        end
      end
      local citem = {item[ITEM_Name], item.states, item.state, item.fn, item.module, nil, nil};
      if (item.export) then
        citem[ITEM_Export] = item.export;
      end
      if (item.virtual) then
        citem[ITEM_Virtual] = {};
        for i, v in ipairs(item.virtual) do
          TRACE("virt: ", i, v.fn, v.module);
          if (v.fn) and (v.fn > 0) and (v.module) and (v.module > 0) then		  
            citem[ITEM_Virtual][i] = {v.fn, v.module};
          end
        end
        TRACE("virts4:", citem[ITEM_Name], citem[ITEM_Virtual]);
      end

      -- validity check
      if (citem[ITEM_Name]) and
      (citem[ITEM_States]) and
      (
        ((citem[ITEM_Function]) and (citem[ITEM_Module]) and (citem[ITEM_Function] > 0) and (citem[ITEM_Module] > 0)) or
        ((citem[ITEM_Virtual]) and (#citem[ITEM_Virtual] > 0))
        ) then
        cmenu[i][k] = citem;
        if (switchId) then
          citem[ITEM_Name] = citem[ITEM_Name] .. "/" .. item.switch;
          local use = {citem, lsmode};
          if not switchUse[switchId] then
            switchUse[switchId] = {use};
          else
            local sc = #switchUse[switchId];
            switchUse[switchId][sc + 1] = use;
          end
        end
      end
    end
  end

  -- resolve virtuals
  for ip, page in ipairs(cmenu) do
    for i, item in ipairs(page) do
      TRACE("virts3:", item[ITEM_Name], item[ITEM_Virtual]);
      if (item[ITEM_Virtual]) then
        local virts = {};
        TRACE("virt2:", item[ITEM_Virtual]);
        for iv, v in ipairs(item[ITEM_Virtual]) do
          local vitem = findItem(cmenu, v[1], v[2]);
          if (vitem) then
            ADD(virts, vitem);
          end
        end
        item[ITEM_Virtual] = virts;
      end
    end
  end

  for switchid, uses in pairs(switchUse) do
    if (#uses > 1) then
      for iu, use in ipairs(uses) do
        local swItem = use[1];
        local lsmode = use[2];
        for ip, page in ipairs(cmenu) do
          for i, item in ipairs(page) do
            if (item == swItem) then
              overlays[ip][#overlays[ip] + 1] = {switchid, item, lsmode};
            end
          end
        end
      end
    else
      local item = uses[1][1];
      local lsmode = uses[1][2];
      shortCuts[#shortCuts + 1] = {switchid, item, lsmode};
    end
  end
  menu = nil;
  switchUse = nil;
  collectgarbage();
  return cmenu, shortCuts, overlays, pagetitles;
end

local function initMenuColor(cfg, menu, filename)
  if not menu then
    return;
  end
  local cmenu, shortCuts, overlays, pagetitles = initMenuBW(menu);

  local menudata = {};

  if (menu.title) then
    menudata[MENUDATA_Title] = menu.title;
  end

  if (cfg[CFG_Footer]) then
    menudata[MENUDATA_Footer] = cfg[CFG_Footer];

    if (filename) then
      menudata[MENUDATA_Footer] = menudata[MENUDATA_Footer] .. " File:" .. filename;
    end
  end
  return cmenu, shortCuts, overlays, pagetitles, menudata;
end


local function initFSM(state)
  if not(state[FSMSWITCH_LastTime]) then
    state[FSMSWITCH_LastTime] = getTime();
    state[FSMSWITCH_State] = 0;
    state[FSMSWITCH_CyclePage] = 1;
    state[FSMSWITCH_CycleRow] = 1;
    return;
  end
end

local function initConfigFSM(state)
  if not(state[FSMCONF_LastTime]) then
    state[FSMCONF_LastTime] = getTime();
    state[FSMCONF_State] = FSMCONF_STATE_Wait; 
    state[FSMCONF_Row] = 0; -- nil 
    return;
  end
end

if (LCD_W <= 128) then
  return { 
    loadConfig = loadConfig,
    loadMenu = loadMenu,
    initWidget = initWidgetBW,
    initMenu = initMenuBW,
    initParamMenu = initParamMenuBW,
    initConfig = initConfigBW,
    initFSM = initFSM,
    initConfigFSM = initConfigFSM,
  };
elseif (LCD_W <= 212) then
  return { 
    loadConfig = loadConfig,
    loadMenu = loadMenu,
    initWidget = initWidgetBW,
    initMenu = initMenuBW,
    initParamMenu = initParamMenuBW,
    initConfig = initConfigBW,
    initFSM = initFSM,
    initConfigFSM = initConfigFSM,
  };
else
  return { 
    loadConfig = loadConfig,
    loadMenu = loadMenu,
    initWidget = initWidgetColor,
    initMenu = initMenuColor,
    initParamMenu = initParamMenuColor,
    initConfig = initConfigColor,
    initFSM = initFSM,
    initConfigFSM = initConfigFSM,
  };
end

