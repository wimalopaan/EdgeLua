--
--
-- EdgeLUA - EdgeTx / OpenTx Extensions 
-- Copyright (C) 2021 Wilhelm Meier <wilhelm.wm.meier@googlemail.com>
--
-- This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License. 
-- To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/ 
-- or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.

-- IMPORTANT
-- Please note that the above license also covers the transfer protocol used and the encoding scheme and 
-- all further principals of tranferring state and other information.

#include "../../global.h"

local function isFullScreen(event)
  return not not event;
end

local function isEdgeTx()
  local ver, radio, maj, minor, rev, osname = getVersion();
  return osname ~= nil;
end

local function isColorLCD()
  return LCD_W >= 480;
end

local function updateWidgetDimensions(widget, event)
end

local function updateWidgetDimensionsEdgeTx(widget, event)
  if (isFullScreen(event)) then
    widget[W_X] = 0;
    widget[W_Y] = 0;
    widget[W_Width] = LCD_W;
    widget[W_Height] = LCD_H;
    widget[W_FontHeight]= widget[W_FontHLarge];
  else
    widget[W_X] = widget[W_Zone].x;
    widget[W_Y] = widget[W_Zone].y;
    widget[W_Width] = widget[W_Zone].w;
    widget[W_Height] = widget[W_Zone].h;
    widget[W_FontHeight]= widget[W_FontHSmall];
  end
end

local function updateWidgetDimensionsOpenTx(widget, event)
end

local function displayFooter(widget, text)
  lcd.drawText(widget[W_X], widget[W_Y] + widget[W_Height] - widget[W_FontHeight], text, SMLSIZE + COLOR_THEME_PRIMARY3);
end

local function displayHeader(widget, text)
  lcd.drawText(widget[W_X] + widget[W_Width] - 60, widget[W_Y], text, SMLSIZE + COLOR_THEME_PRIMARY3);
end

local function displayInfo(widget, text)
  lcd.drawText(widget[W_X] + widget[W_Width] - 60, widget[W_Y] + widget[W_FontHeight], text, SMLSIZE + COLOR_THEME_PRIMARY3);
end

local function displayFooterNoTheme(widget, text)
  lcd.drawText(widget[W_X], widget[W_Y] + widget[W_Height] - widget[W_FontHeight], text, SMLSIZE);
end

local function displayHeaderNoTheme(widget, text)
  lcd.drawText(widget[W_X] + widget[W_Width] - 60, widget[W_Y], text, SMLSIZE);
end

local function displayInfoNoTheme(widget, text)
  lcd.drawText(widget[W_X] + widget[W_Width] - 60, widget[W_Y] + widget[W_FontHeight], text, SMLSIZE);
end

local function displayParamMenuBW(config, widget, pmenu, pheaders, state, paramScaler)
  local activePageIndex = state[MENUSTATE_Page];
  local page = pmenu[activePageIndex];
  local header = pheaders[activePageIndex];
  lcd.clear()

  if (config[CFG_Backend] == CFG_BEND_TipTip) or (config[CFG_Backend] == CFG_BEND_SolExpert) then
    lcd.drawText(widget[W_X], widget[W_Y], "Not usable with backend: " .. config[CFG_Backend], MIDSIZE);
    return 0;
  end

  lcd.drawScreenTitle(header[PHEADER_Title] .. "/" .. header[PHEADER_Module], activePageIndex, #pheaders);

  local maxParamsPerLine = 1;
  for headerRow = PHEADER_LinesStart, #header do -- Param header
    local hline = header[headerRow];
    if (#hline > maxParamsPerLine) then
      maxParamsPerLine = #hline;
    end
  end
  local fw = (widget[W_Width] - config[CFG_FirstColWidth]) / maxParamsPerLine;

  for headerRow = PHEADER_LinesStart, #header do 
    local hline = header[headerRow];
    local x = widget[W_X];
    local y = widget[W_Y] + widget[W_YOffset] + (headerRow - PHEADER_LinesStart) * widget[W_FontHeight];      
    x = x + config[CFG_FirstColWidth];
    for col, item in ipairs(hline) do
      lcd.drawText(x, y, item[PHITEM_Name], SMLSIZE);
      x = x + fw;
    end      
  end

  local pvalue, percent = paramScaler(config);
  local x = widget[W_X];
  local y = widget[W_Y] + widget[W_YOffset];
  if ((state[MENUSTATE_SelRow] > 0) and (state[MENUSTATE_SelCol] > 0)) then
    lcd.drawText(x, y, pvalue .. "[" .. percent .. "%]", SMLSIZE + INVERS);
    local line = page[state[MENUSTATE_SelRow]];
    line[PLINE_Values][state[MENUSTATE_SelCol]] = pvalue;
  else
    lcd.drawText(x, y, pvalue .. "[" .. percent .. "%]", SMLSIZE);
  end

  for row, line in ipairs(page) do
    local x = widget[W_X];
    local y = widget[W_Y] + widget[W_YOffset] + (#header + row - PHEADER_LinesStart) * widget[W_FontHeight];
    local label = line[PLINE_Item][PITEM_Name];

    if (row == state[MENUSTATE_Row]) then
      lcd.drawText(x, y, label, SMLSIZE + INVERS);
    else
      lcd.drawText(x, y, label, SMLSIZE);
    end

    x = x + config[CFG_FirstColWidth];
    for col, pv in ipairs(line[PLINE_Values]) do
      if ((row == state[MENUSTATE_SelRow]) and (col == state[MENUSTATE_SelCol])) then
        lcd.drawText(x, y, pv, SMLSIZE + INVERS);
      else
        if ((row == state[MENUSTATE_Row]) and (col == state[MENUSTATE_Col])) then
          lcd.drawText(x, y, pv, SMLSIZE + INVERS + BLINK);
        else
          lcd.drawText(x, y, pv, SMLSIZE);
        end
      end
      x = x + fw;
    end
  end   
  return pvalue;
end

local function displayParamMenuColorNoTheme(config, widget, pmenu, pheaders, state, paramScaler, event, help)
  lcd.clear()
  local activePageIndex = state[MENUSTATE_Page];
  local page = pmenu[activePageIndex];
  local header = pheaders[activePageIndex];

  if (config[CFG_Backend] == CFG_BEND_TipTip) or (config[CFG_Backend] == CFG_BEND_SolExpert) then
    lcd.drawText(widget[W_X], widget[W_Y], "Not usable with backend: " .. config[CFG_Backend], MIDSIZE);
    return 0;
  end

  lcd.drawText(widget[W_X], widget[W_Y], header[PHEADER_Title] .. " [" .. header[PHEADER_Module] .."]", MIDSIZE);

  displayHeaderNoTheme(widget, "Page " .. activePageIndex .. "/" .. #pmenu);

  if (pmenu.footer) then
    displayFooterNoTheme(widget, pmenu.footer);
  end

  local maxParamsPerLine = 1;
  for headerRow = PHEADER_LinesStart, #header do -- Param header
    local hline = header[headerRow];
    if (#hline > maxParamsPerLine) then
      maxParamsPerLine = #hline;
    end
  end
  local fw = (widget[W_Width] - config[CFG_FirstColWidth]) / maxParamsPerLine;

  for headerRow = PHEADER_LinesStart, #header do 
    local hline = header[headerRow];
    local x = widget[W_X];
    local y = widget[W_Y] + widget[W_YOffset] + (headerRow - PHEADER_LinesStart) * widget[W_FontHeight];      
    x = x + config[CFG_FirstColWidth];
    for col, item in ipairs(hline) do
      lcd.drawText(x, y, item[PHITEM_Name], SMLSIZE);
      x = x + fw;
    end      
  end

  if (help) then
    local htext = help[activePageIndex];
    if (htext) then
      lcd.drawText(widget[W_X], widget[W_Y] + widget[W_Height] - 2 * widget[W_FontHeight], "Hilfe: " .. htext, SMLSIZE);
    end 
  end 

  local pvalue, percent = paramScaler(config);
  local x = widget[W_X];
  local y = widget[W_Y] + widget[W_YOffset];
  if ((state[MENUSTATE_SelRow] > 0) and (state[MENUSTATE_SelCol] > 0)) then
    lcd.drawText(x, y, pvalue .. "[" .. percent .. "%]", SMLSIZE + INVERS);
    local line = page[state[MENUSTATE_SelRow]];
    line[PLINE_Values][state[MENUSTATE_SelCol]] = pvalue;
  else
    lcd.drawText(x, y, pvalue .. "[" .. percent .. "%]", SMLSIZE);
  end

  for row, line in ipairs(page) do
    line[PLINE_Rects] = {};
    local x = widget[W_X];
    local y = widget[W_Y] + widget[W_YOffset] + (#header + row - 3) * widget[W_FontHeight];
    local label = line[PLINE_Item][ITEM_Name];
    if (line[PLINE_Line] > 1) then
      label = "--" .. label;
    end
    if (row == state[MENUSTATE_Row]) then
      lcd.drawText(x, y, label, SMLSIZE + INVERS);
    else
      lcd.drawText(x, y, label, SMLSIZE);
    end

    x = x + config[CFG_FirstColWidth];
    for col, pv in ipairs(line[PLINE_Values]) do
      local rect = {xmin = x, ymin = y, xmax = x + fw, ymax = y + widget[W_FontHeight]};
      line[PLINE_Rects][col] = rect;

      if ((row == state[MENUSTATE_SelRow]) and (col == state[MENUSTATE_SelCol])) then
        lcd.drawText(x, y, pv, SMLSIZE + INVERS);
      else
        if ((row == state[MENUSTATE_Row]) and (col == state[MENUSTATE_Col])) then
          lcd.drawText(x, y, pv, SMLSIZE + INVERS + BLINK);
        else
          lcd.drawText(x, y, pv, SMLSIZE);
        end
      end
      x = x + fw;
    end
  end   
  return pvalue;
end


local function displayParamMenuColor(config, widget, pmenu, pheaders, state, paramScaler, event, help)
  lcd.clear()
  if (config[CFG_Backend] == CFG_BEND_TipTip) or (config[CFG_Backend] == CFG_BEND_SolExpert) then
    lcd.drawText(widget[W_X], widget[W_Y], "Not usable with backend: " .. config[CFG_Backend], MIDSIZE + COLOR_THEME_WARNING);
    return 0;
  end

  local activePageIndex = state[MENUSTATE_Page];
  local page = pmenu[activePageIndex];
  local header = pheaders[activePageIndex];

  lcd.drawText(widget[W_X], widget[W_Y], header[PHEADER_Title] .. " [" .. header[PHEADER_Module] .."]", MIDSIZE + COLOR_THEME_PRIMARY3);

  displayHeader(widget, "Page " .. activePageIndex .. "/" .. #pmenu);

  if (pmenu.footer) then
    displayFooter(widget, pmenu.footer);
  end

  local maxParamsPerLine = 1;
  for headerRow = PHEADER_LinesStart, #header do -- Param header
    local hline = header[headerRow];
    if (#hline > maxParamsPerLine) then
      maxParamsPerLine = #hline;
    end
  end
  local fw = (widget[W_Width] - config[CFG_FirstColWidth]) / maxParamsPerLine;

  for headerRow = PHEADER_LinesStart, #header do 
    local hline = header[headerRow];
    local x = widget[W_X];
    local y = widget[W_Y] + widget[W_YOffset] + (headerRow - PHEADER_LinesStart) * widget[W_FontHeight];      
    x = x + config[CFG_FirstColWidth];
    for col, item in ipairs(hline) do
      lcd.drawText(x, y, item[PHITEM_Name], SMLSIZE);
      x = x + fw;
    end      
  end

  if (help) then
    local htext = help[activePageIndex];
    if (htext) then
      lcd.drawText(widget[W_X], widget[W_Y] + widget[W_Height] - 2 * widget[W_FontHeight], "Hilfe: " .. htext, SMLSIZE + COLOR_THEME_PRIMARY1);
    end 
  end 

  local pvalue, percent = paramScaler(config);
  local x = widget[W_X];
  local y = widget[W_Y] + widget[W_YOffset];
  if ((state[MENUSTATE_SelRow] > 0) and (state[MENUSTATE_SelCol] > 0)) then
    lcd.drawText(x, y, pvalue .. "[" .. percent .. "%]", SMLSIZE + COLOR_THEME_WARNING);
    local line = page[state[MENUSTATE_SelRow]];
    line[PLINE_Values][state[MENUSTATE_SelCol]] = pvalue;
  else
    lcd.drawText(x, y, pvalue .. "[" .. percent .. "%]", SMLSIZE + COLOR_THEME_PRIMARY3);
  end

  for row, line in ipairs(page) do
    line[PLINE_Rects] = {};
    local x = widget[W_X];
    local y = widget[W_Y] + widget[W_YOffset] + (#header + row - 3) * widget[W_FontHeight];
    local label = line[PLINE_Item][PITEM_Name];
    if (line[PLINE_Line] > 1) then
      label = "--" .. label;
    end
    if (row == state[MENUSTATE_Row]) then
      lcd.drawText(x, y, label, SMLSIZE + INVERS + COLOR_THEME_SECONDARY2, COLOR_THEME_PRIMARY2);
    else
      lcd.drawText(x, y, label, SMLSIZE + COLOR_THEME_PRIMARY1);
    end

    x = x + config[CFG_FirstColWidth];
    for col, st in ipairs(line[PLINE_Values]) do
      local rect = {xmin = x, ymin = y, xmax = x + fw, ymax = y + widget[W_FontHeight]};
      line[PLINE_Rects][col] = rect;

      if ((row == state[MENUSTATE_SelRow]) and (col == state[MENUSTATE_SelCol])) then
        lcd.drawText(x, y, st, SMLSIZE + INVERS + COLOR_THEME_SECONDARY2, COLOR_THEME_PRIMARY2);
        if (event) then
          lcd.drawRectangle(x - 1, y - 1, fw - 1, widget[W_FontHeight]- 1, COLOR_THEME_ACTIVE);
        end
      else
        if ((row == state[MENUSTATE_Row]) and (col == state[MENUSTATE_Col])) then
          lcd.drawText(x, y, st, SMLSIZE + INVERS + BLINK + COLOR_THEME_SECONDARY2, COLOR_THEME_PRIMARY2);
          if (event) then
            lcd.drawRectangle(x - 1, y - 1, fw - 1, widget[W_FontHeight]- 1, COLOR_THEME_FOCUS);
          end
        else
          lcd.drawText(x, y, st, SMLSIZE+ COLOR_THEME_PRIMARY1);
          if (event) then
            lcd.drawRectangle(x - 1, y - 1, fw - 1, widget[W_FontHeight]- 1, COLOR_THEME_PRIMARY3);
          end
        end
      end
      x = x + fw;
    end
  end   
  return pvalue;
end


local function displayMenuBW(config, widget, menu, overlays, state, pagetitles)
  lcd.clear()
  local activePageIndex = state[MENUSTATE_Page];
  local page = menu[activePageIndex];
  local overlay = overlays[activePageIndex];

  TRACE3("displayMenuBW", pagetitles, pagetitles[activePageIndex]);
  if (pagetitles[activePageIndex]) then
    lcd.drawScreenTitle(pagetitles[activePageIndex], activePageIndex, #menu);
  else
    lcd.drawScreenTitle(config[CFG_Title], activePageIndex, #menu);
  end

  for row, item in ipairs(page) do
    local x = widget[W_X];
    local y = widget[W_Y] + widget[W_YOffset] + (row - 1) * widget[W_FontHeight];

    local label = item[ITEM_Name];
    if (item[ITEM_Virtual]) then
      label = label .. "#";
    end

    for io, o in ipairs(overlay) do
      if (o[OVERLAY_Item] == item) then
        label = label .. "*";
      end
    end

    if (row == state[MENUSTATE_Row]) then
      lcd.drawText(x, y, label, SMLSIZE + INVERS);
    else
      lcd.drawText(x, y, label, SMLSIZE);
    end

    local fw = (widget[W_Width] - config[CFG_FirstColWidth]) / #item[ITEM_States];
    x = x + config[CFG_FirstColWidth];

    for col, st in ipairs(item[ITEM_States]) do
      if (col == item[ITEM_State]) then
        lcd.drawText(x, y, st, SMLSIZE + INVERS);
      else 
        if (state[MENUSTATE_Col] == col) and (row == state[MENUSTATE_Row]) then
          lcd.drawText(x, y, st, SMLSIZE + INVERS + BLINK);
        else
          lcd.drawText(x, y, st);
        end
      end
      x = x + fw;
    end
  end
end

local function displayMenuColor(config, widget, menu, overlays, state, event, remote, 
                                warning1, warning2, pagetitles, menudata, fsmState)
  lcd.clear()

  if (warning1) then
    local ww1, wh1 = lcd.sizeText(warning1, DBLSIZE);
    lcd.drawText(widget[W_X] + widget[W_Width] / 2 - ww1 / 2, widget[W_Y] + widget[W_Height] / 2 - wh1,
      warning1, DBLSIZE + COLOR_THEME_WARNING);
    if (warning2) then
      local ww2, wh2 = lcd.sizeText(warning2, XXLSIZE);
      lcd.drawText(widget[W_X] + widget[W_Width] / 2 - ww2 / 2, widget[W_Y] + widget[W_Height] / 2,
        warning2, XXLSIZE + COLOR_THEME_WARNING);
    end
  end

  local activePageIndex = state[MENUSTATE_Page];
  local page = menu[activePageIndex];
  local overlay = overlays[activePageIndex];

  if (pagetitles[activePageIndex]) then
    lcd.drawText(widget[W_X], widget[W_Y], pagetitles[activePageIndex], MIDSIZE + COLOR_THEME_PRIMARY3);
  else
    if (menudata[MENUDATA_Title]) then
      lcd.drawText(widget[W_X], widget[W_Y], menudata[MENUDATA_Title], MIDSIZE + COLOR_THEME_PRIMARY3);
    end
  end

  displayHeader(widget, "Page" .. activePageIndex .. "/" .. #menu);

  if (menudata[MENUDATA_Footer]) then
    displayFooter(widget, menudata[MENUDATA_Footer]);
  end

  if ((fsmState) and (config[CFG_Backend] == CFG_BEND_TipTip)) then
    if (fsmState[FSMTIP_Busy]) then
      lcd.drawText(widget[W_X] + widget[W_Width] - 40, widget[W_Y] + widget[W_Height] - widget[W_FontHeight], 
                  "Busy!", SMLSIZE + COLOR_THEME_WARNING);
    end
  end 

  if (config[CFG_RemoteId]) then
    lcd.drawText(widget[W_X] + widget[W_Width] - 70, widget[W_Y] + widget[W_Height] - widget[W_FontHeight],
      "r[" .. remote[REMOTE_Function] .. "," .. remote[REMOTE_Module] .. "," .. remote[REMOTE_State] .. "]:" .. remote[REMOTE_LastValue],
      SMLSIZE + COLOR_THEME_PRIMARY3);
  end

  for row, item in ipairs(page) do
    item[ITEM_Rects] = {};
    local x = widget[W_X];
    local y = widget[W_Y] + widget[W_YOffset] + (row - 1) * widget[W_FontHeight];

    local label = item[ITEM_Name];
    if (item[ITEM_Virtual]) then
      label = label .. "#";
    end

    for io, o in ipairs(overlay) do
      if (o[OVERLAY_Item] == item) then
        label = label .. "*";
      end
    end

    if (row == state[MENUSTATE_Row]) then
      lcd.drawText(x, y, label, SMLSIZE + INVERS + COLOR_THEME_SECONDARY2, COLOR_THEME_PRIMARY2);
    else
      lcd.drawText(x, y, label, SMLSIZE + COLOR_THEME_PRIMARY1);
    end

    local fw = (widget[W_Width] - config[CFG_FirstColWidth]) / #item[ITEM_States];
    x = x + config[CFG_FirstColWidth];

    for col, st in ipairs(item[ITEM_States]) do
      local rect = {xmin = x, ymin = y, xmax = x + fw, ymax = y + widget[W_FontHeight]};
      item[ITEM_Rects][col] = rect;
      if (col == item[ITEM_State]) then -- active
        lcd.drawText(x, y, st, SMLSIZE + INVERS + COLOR_THEME_SECONDARY2, COLOR_THEME_PRIMARY2);
        if (event) then
          lcd.drawRectangle(x - 1, y - 1, fw - 1, widget[W_FontHeight]- 1, COLOR_THEME_ACTIVE);
        end
      else 
        if (state[MENUSTATE_Col] == col) and (row == state[MENUSTATE_Row]) then -- focus
          lcd.drawText(x, y, st, SMLSIZE + INVERS + BLINK + COLOR_THEME_SECONDARY2, COLOR_THEME_PRIMARY2);
          if (event) then
            lcd.drawRectangle(x - 1, y - 1, fw - 1, widget[W_FontHeight]- 1, COLOR_THEME_FOCUS);
          end
        else -- 
          lcd.drawText(x, y, st, SMLSIZE + COLOR_THEME_PRIMARY1);
          if (event) then
            lcd.drawRectangle(x - 1, y - 1, fw - 1, widget[W_FontHeight]- 1, COLOR_THEME_PRIMARY3);
          end
        end
      end
      x = x + fw;
    end
  end
end

local function displayMenuColorNoTheme(config, widget, menu, overlays, state, event, remote, warning1, warning2, pagetitles, menudata)
--  lcd.clear()
--  TRACE("displayMenuColorNoTheme", widget[W_X], widget[W_Y], widget[W_Width], widget[W_Height]);

  if (warning) then
    local ww, wh = lcd.sizeText(warning, DBLSIZE);
    lcd.drawText(widget[W_X] + widget[W_Width] / 2 - ww / 2, widget[W_Y] + widget[W_Height] / 2 - wh / 2,
      warning, XXLSIZE);
  end

  local activePageIndex = state[MENUSTATE_Page];
  local page = menu[activePageIndex];
  local overlay = overlays[activePageIndex];

  if (pagetitles[activePageIndex]) then
    lcd.drawText(widget[W_X], widget[W_Y], pagetitles[activePageIndex], MIDSIZE);
  else
    if (menudata[MENUDATA_Title]) then
      lcd.drawText(widget[W_X], widget[W_Y], menudata[MENUDATA_Title], MIDSIZE);
    end
  end

  displayHeaderNoTheme(widget, activePageIndex .. "/" .. #menu);

  if (menudata[MENUDATA_Footer]) then
    displayFooterNoTheme(widget, menudata[MENUDATA_Footer]);
  end

  for row, item in ipairs(page) do
    item[ITEM_Rects] = {};
    local x = widget[W_X];
    local y = widget[W_Y] + widget[W_YOffset] + (row - 1) * widget[W_FontHeight];

    local label = item[ITEM_Name];
    if (item[ITEM_Virtual]) then
      label = label .. "#";
    end

    for io, o in ipairs(overlay) do
      if (o[OVERLAY_Item] == item) then
        label = label .. "*";
      end
    end

    if (row == state[MENUSTATE_Row]) then
      lcd.drawText(x, y, label, SMLSIZE + INVERS);
    else
      lcd.drawText(x, y, label, SMLSIZE);
    end

    local fw = (widget[W_Width] - config[CFG_FirstColWidth]) / #item[ITEM_States];
    x = x + config[CFG_FirstColWidth];

    for col, st in ipairs(item[ITEM_States]) do
      local rect = {xmin = x, ymin = y, xmax = x + fw, ymax = y + widget[W_FontHeight]};
      item[ITEM_Rects][col] = rect;
      if (col == item[ITEM_State]) then -- active
        lcd.drawText(x, y, st, SMLSIZE + INVERS);
      else 
        if (state[MENUSTATE_Col] == col) and (row == state[MENUSTATE_Row]) then -- focus
          lcd.drawText(x, y, st, SMLSIZE + INVERS + BLINK);
        else -- 
          lcd.drawText(x, y, st, SMLSIZE);
        end
      end
      x = x + fw;
    end
  end
end

local function prevPage(menu, menuState)
  if (menuState[MENUSTATE_Page] == 1) then
    menuState[MENUSTATE_Page] = #menu;
  else
    menuState[MENUSTATE_Page] = menuState[MENUSTATE_Page] - 1;
  end
end

local function nextPage(menu, menuState)
  if (menuState[MENUSTATE_Page] == #menu) then
    menuState[MENUSTATE_Page] = 1;
  else
    menuState[MENUSTATE_Page] = menuState[MENUSTATE_Page] + 1;
  end
end

local function prevRow(menu, menuState)
  if (menuState[MENUSTATE_Row] == 1) then
    prevPage(menu, menuState);
    menuState[MENUSTATE_Row] = #menu[menuState[MENUSTATE_Page]];
  else
    menuState[MENUSTATE_Row] = menuState[MENUSTATE_Row] - 1;
  end
end

local function nextRow(menu, menuState)
  if (menuState[MENUSTATE_Row] == #menu[menuState[MENUSTATE_Page]]) then
    nextPage(menu, menuState);
    menuState[MENUSTATE_Row] = 1;
  else
    menuState[MENUSTATE_Row] = menuState[MENUSTATE_Row] + 1; 
  end
end

local function prevCol(menu, menuState)
  if (menuState[MENUSTATE_Col] == 1) then
    prevRow(menu, menuState);
    menuState[MENUSTATE_Col] = #menu[menuState[MENUSTATE_Page]][menuState[MENUSTATE_Row]][MENUSTATE_Col];
  else
    menuState[MENUSTATE_Col] = menuState[MENUSTATE_Col] - 1;
  end
end

local function nextCol(menu, menuState)
  if (menuState[MENUSTATE_Col] == #menu[menuState[MENUSTATE_Page]][menuState[MENUSTATE_Row]][MENUSTATE_Col]) then
    nextRow(menu, menuState);
    menuState[MENUSTATE_Col] = 1;
  else
    menuState[MENUSTATE_Col] = menuState[MENUSTATE_Col] + 1;
  end
end

local function menuDeselect(menuState)
  menuState[MENUSTATE_SelRow] = 0;
  menuState[MENUSTATE_SelCol] = 0;
  #ifdef USE_VALUE_STORAGE
    menuState[MENUSTATE_Dirty] = true;
  #endif
end

local function makeSelection(menuState)
  menuState[MENUSTATE_SelRow] = menuState[MENUSTATE_Row]; -- selection
  menuState[MENUSTATE_SelCol] = menuState[MENUSTATE_Col];
end

local function setAndPushItem(queue, item, newState)
  local push = {[PUSHED_ITEM_Item] = item, [PUSHED_ITEM_BeforeState] = item[ITEM_State]};
  item[ITEM_State] = newState;
  queue:push(push);
end

local function selectParamItem(menu, menuState, queue)
  makeSelection(menuState);
  local page = menu[menuState[MENUSTATE_Page]];
  local pitem = page[menuState[MENUSTATE_Row]];
  local item = pitem;
  queue:push(item);
  #ifdef USE_VALUE_STORAGE
    menuState[MENUSTATE_Dirty] = true;
  #endif
end

local function selectItem(menu, menuState, queue)
  makeSelection(menuState);
  local page = menu[menuState[MENUSTATE_Page]];
  local item = page[menuState[MENUSTATE_Row]];
  setAndPushItem(queue, item, menuState[MENUSTATE_Col]);
  -- local push = {[PUSHED_ITEM_Item] = item, [PUSHED_ITEM_BeforeState] = item[ITEM_State]};
  -- item[ITEM_State] = menuState[MENUSTATE_Col];
  -- queue:push(push);
end

#ifdef DEBUG
local lastEvent = 0;
#endif
local function processEventsBWScroll(config, menu, menuState, event, queue, callback)
  if (event == EVT_VIRTUAL_ENTER) then
    callback(menu, menuState, queue);
  else
    #ifdef DEBUG
    if (event ~= lastEvent) then
      TRACE2("processEventsBWScroll", event);
      lastEvent = event;      
    end
    #endif
    if (event > 0) then
      menuDeselect(menuState);
    end
    if (event == EVT_VIRTUAL_INC) then -- same as EVT_VIRTUAL_NEXT
      prevCol(menu, menuState);
    elseif (event == EVT_VIRTUAL_DEC) then -- same as EVT_VIRTUAL_PREV
      nextCol(menu, menuState);
    elseif (event == EVENT_X9E_MENU) then
      prevRow(menu, menuState);
    elseif (event == EVENT_X9E_EXIT) then
      nextRow(menu, menuState);
    end
  end
end

local function processEventsBWKeys(config, menu, menuState, event, queue, callback)
  TRACE3("processEventsBWKeys A");
  if (event == EVT_VIRTUAL_ENTER) then
    callback(menu, menuState, queue);
  else
    #ifdef DEBUG
    if (event ~= lastEvent) then
      TRACE2("processEventsBWKeys", event);
      lastEvent = event;      
    end
    #endif
    if (event > 0) then
      menuDeselect(menuState);
    end
    if (event == EVT_VIRTUAL_INC) then
      prevRow(menu, menuState);
    elseif (event == EVT_VIRTUAL_DEC) then
      nextRow(menu, menuState);
    elseif (event == EVT_VIRTUAL_PREV) or (event == 101) then
      prevCol(menu, menuState);
    elseif (event == EVT_VIRTUAL_NEXT) or (event == 100) then
      nextCol(menu, menuState);
    end
  end
  TRACE3("processEventsBWKeys E");
end

local function processEventsColor(config, menu, menuState, event, queue, callback)
  if (event == EVT_VIRTUAL_ENTER) then
    callback(menu, menuState, queue);
  else
    if (event) and (event > 0) then
      menuDeselect(menuState);
    end
    if (event == EVT_VIRTUAL_INC) then
      prevCol(menu, menuState);
    elseif (event == EVT_VIRTUAL_DEC) then
      nextCol(menu, menuState);
    elseif (event == EVT_VIRTUAL_PREV) or (event == 101) then
      prevCol(menu, menuState);
    elseif (event == EVT_VIRTUAL_NEXT) or (event == 100) then
      nextCol(menu, menuState);
    elseif (event == 0x601) then
      nextCol(menu, menuState);
    elseif (event == 0x600) then
      prevCol(menu, menuState);
    elseif (event == 0x605) then
      nextRow(menu, menuState);
    elseif (event == 0x604) then
      prevRow(menu, menuState);
    elseif (event == 0x801) then
      nextPage(menu, menuState);
    elseif (event == 0x800) then
      prevPage(menu, menuState);
    end
  end
end

local function getSwitchValue(id, lsmode)
  local value = getValue(id);
  if (lsmode == 0) then
    if (value == 0) then
      return 1;
    elseif (value > 0) then
      return 2;
    else
      return 3;
    end
  elseif (lsmode == 1) then
    if (value < 0) then
      return 1;
    else
      return 2;
    end
  else
    if (value < 0) then
      return 1;
    else
      return 3;
    end
  end
end

local function processShortCuts(shortCuts, queue)
  for i, sc in ipairs(shortCuts) do
    local v = getSwitchValue(sc[SHORTCUT_SwitchID], sc[SHORTCUT_LSMode]);
    if not (v == sc[SHORTCUT_LastValue]) then
      sc[SHORTCUT_LastValue] = v;
      local item = sc[SHORTCUT_Item];
      setAndPushItem(queue, item, v);
      -- local push = {[PUSHED_ITEM_Item] = item, [PUSHED_ITEM_BeforeState] = item[ITEM_State]};
      -- item[ITEM_State] = v;
      -- queue:push(push);
    end
  end
end

local function processOverlays(overlays, menuState, queue)
  local activePageIndex = menuState[MENUSTATE_Page];
  local overlay = overlays[activePageIndex];
  processShortCuts(overlay, queue);
end

local function processTrimsSelect(config, buttonState, callback)
  TRACE3("processTrimsSelect: ", config[CFG_SelectLsId], buttonState, callback);
  if (config[CFG_SelectLsId]) then
    local value = getValue(config[CFG_SelectLsId]);
    TRACE3("processTrimsSelect value:", value);
    if (value > buttonState[BUTTONS_SELECT]) then
      TRACE3("processTrimsSelect select cb");
      callback();
    end
    buttonState[BUTTONS_SELECT] = value;
  end
end

local function processTrimsPrevious(config, buttonState, callback)
  if (config[CFG_PreviousLsId]) then
    local value = getValue(config[CFG_PreviousLsId]);
    if (value > buttonState[BUTTONS_PREV]) then
      callback();
    end
    buttonState[BUTTONS_PREV] = value;
  end
end

local function processTrimsNext(config, buttonState, callback)
  if (config[CFG_NextLsId]) then
    local value = getValue(config[CFG_NextLsId]);
    if (value > buttonState[BUTTONS_NEXT]) then
      callback();
    end
    buttonState[BUTTONS_NEXT] = value;
  end
end

local function processTrims(config, menu, menuState, buttonState, queue, callback)
  TRACE3("processTrims");
  local prevCB = function() 
    prevCol(menu, menuState);
    menuDeselect(menuState);
  end
  processTrimsPrevious(config, buttonState, prevCB);
  --[[
  if (config[CFG_PreviousLsId]) then
    local value = getValue(config[CFG_PreviousLsId]);
    TRACE3("processTrims prev", config[CFG_PreviousLsId], value);
    if (value > buttonState[BUTTONS_PREV]) then
      prevCol(menu, menuState);
      menuDeselect(menuState);
    end
    buttonState[BUTTONS_PREV] = value;
  end
  --]]
  local nextCB = function()
    nextCol(menu, menuState);
    menuDeselect(menuState);
  end
  processTrimsNext(config, buttonState, nextCB);
  --[[
  if (config[CFG_NextLsId]) then
    local value = getValue(config[CFG_NextLsId]);
--    TRACE("processTrims next", config[CFG_NextLsId], value);
    if (value > buttonState[BUTTONS_NEXT]) then
      nextCol(menu, menuState);
      menuDeselect(menuState);
    end
    buttonState[BUTTONS_NEXT] = value;
  end
  --]]

  local selectCB = function()
    TRACE("selectCB");
    callback(menu, menuState, queue);
  end
  processTrimsSelect(config, buttonState, selectCB);

  --[[
  if (config[CFG_SelectLsId]) then
    local value = getValue(config[CFG_SelectLsId]);
--    TRACE("processTrims select", config[CFG_SelectLsId], value);
    if (value > buttonState[BUTTONS_SELECT]) then
      callback(menu, menuState, queue);
    end
    buttonState[BUTTONS_SELECT] = value;
  end
  --]]
end

local function processPots(config, menu, menuState, buttonState)
  if (config[CFG_ScrollUdId]) then
    local activePageIndex = menuState[MENUSTATE_Page];
    local page = menu[activePageIndex];
    local value = getValue(config[CFG_ScrollUdId]) + 1024;
    local row = #page - math.floor(value * #page / 2049);
    if (row ~= buttonState[BUTTONS_SLIDER_UD]) then
      menuState[MENUSTATE_Row] = row;
      buttonState[BUTTONS_SLIDER_UD] = row;
      menuDeselect(menuState);
    end
  end
  if (config[CFG_ScrollLrId]) then
    local activePageIndex = menuState[MENUSTATE_Page];
    local page = menu[activePageIndex];
    local item = page[menuState[MENUSTATE_Row]];
    local value = getValue(config[CFG_ScrollLrId]) + 1024;
    if (item) then
      local col = math.floor(value * #item[ITEM_States] / 2049) + 1;
      if (col ~= buttonState[BUTTONS_SLIDER_LR]) then
        menuState[MENUSTATE_Col] = col;
        buttonState[BUTTONS_SLIDER_LR] = col;
        menuDeselect(menuState);
      end
    end
  end
end

local function processMenuSwitch(config, menu, menuState, buttonState)
  if (config[CFG_PageSwitchId]) then
    local ms = getValue(config[CFG_PageSwitchId]);
    if (math.abs(ms - buttonState[BUTTONS_MENUSELECT]) > 10) then
      local s = 1;
      for i = 0,5 do
        if (ms <= (-1024 + (2 * i  + 1) * (2048 / 6))) then
          s = i + 1;
          break;
        end
      end
      if (s <= #menu) then
        menuState[MENUSTATE_Page] = s;
      end
      buttonState[BUTTONS_MENUSELECT] = ms;
      menuDeselect(menuState);
    end
  end
end

local function processButtons(config, menu, menuState, buttonState, queue, callback)
  processTrims(config, menu, menuState, buttonState, queue, callback);
  processPots(config, menu, menuState, buttonState);
  processMenuSwitch(config, menu, menuState, buttonState);
end

local function covers(touch, item) 
  if ((touch.x >= item.xmin) and (touch.x <= item.xmax)
    and (touch.y >= item.ymin) and (touch.y <= item.ymax)) then
    return true;
  end
  return false;
end

local function processTouch(menu, menuState, event, touch)
  if (touch) then
    local activePageIndex = menuState[MENUSTATE_Page];
    local page = menu[activePageIndex];
    if (event == EVT_TOUCH_TAP) then
      for row, item in ipairs(page) do
        for col, rect in ipairs(item[ITEM_Rects]) do   
          if (covers(touch, rect)) then
            menuState[MENUSTATE_Row] = row;
            menuState[MENUSTATE_Col] = col;
          end
        end
      end
    end
    if (event == EVT_TOUCH_SLIDE) then
      if (touch.swipeLeft) then
        prevPage(menu, menuState);
      end
      if (touch.swipeRight) then
        nextPage(menu, menuState);
      end
    end
  end
end

local function findItem(cmenu, fn, module) -- compressed-menu
  for ip, page in ipairs(cmenu) do
    for i, item in ipairs(page) do
      if (item[ITEM_Function]) and (item[ITEM_Module]) and (item[ITEM_Function] == fn) and (item[ITEM_Module] == module) then
        return item;
      end
    end
  end
  return nil;
end

local function processForeignInput(config, foreignInput, menu, queue)
  local state = foreignInput % 10;
  foreignInput = math.floor(foreignInput / 10);
  local fn = foreignInput % 10;
  foreignInput = math.floor(foreignInput / 10);
  local module = foreignInput % 10;

  local item = findItem(menu, fn, module);
  if (item) then
    setAndPushItem(queue, item, state);
    -- local push = {[PUSHED_ITEM_Item] = item, [PUSHED_ITEM_BeforeState] = item[ITEM_State]};
    -- item[ITEM_State] = state;
    -- queue:push(push);
  end
end

local function processRemoteInput(config, menu, queue, remoteState)
  if (not config[CFG_RemoteId]) then
    return;
  end

  local r = (getValue(config[CFG_RemoteId]) + 1024) / 2;

  if (r == remoteState[REMOTE_LastValue]) then
    return;
  end
  remoteState[REMOTE_LastValue] = r;

  local state = bit32.extract(r, 0, 3) + 1;
  local fn = bit32.extract(r, 3, 3) + 1;
  local module = bit32.extract(r, 6, 3) + 1;

  local item = findItem(menu, fn, module);
  if (item) then
    remoteState[REMOTE_Module] = module;
    remoteState[REMOTE_Function] = fn;
    remoteState[REMOTE_State] = state;
    TRACE("remote: ", module, fn, state);
    setAndPushItem(queue, item, state);
    -- local push = {[PUSHED_ITEM_Item] = item, [PUSHED_ITEM_BeforeState] = item[ITEM_State]};
    -- item[ITEM_State] = state;
    -- queue:push(push);
  end
end

local function displayFmRssiWarningColor(config, widget, state)
  local fm = getFlightMode();
  if (fm == config[CFG_SafeMode_FlightMode]) then
    TRACE("safemode");
  end   
end 

local function displayAddressConfigBW(config, encoder, pScaler, state, event)
  if (config[CFG_Backend] == CFG_BEND_TipTip) or (config[CFG_Backend] == CFG_BEND_SolExpert) then
    lcd.drawText(widget[W_X], widget[W_Y], "Not usable with backend: " .. config[CFG_Backend], MIDSIZE);
    return;
  end

  if (state[FSMADR_State] == FSMADR_STATE_Initial) then

    lcd.drawText(0, 0, "Attach only one device to the RX.", SMLSIZE);

    lcd.drawText(0, 10, "Press [Enter] to start learning", MIDSIZE);

    if (event == EVT_VIRTUAL_ENTER) then
      state[FSMADR_State] = FSMADR_STATE_Output;
    end
  elseif (state[FSMADR_State] == FSMADR_STATE_Output) then    
    local adr = pScaler(config) + 1;
    if (adr > 8) then
      adr = 8;
    end 

    lcd.drawText(0, 0, "Address: " .. adr, MIDSIZE + INVERS);

    lcd.drawText(0, 20, "Watch for the device to respond.", SMLSIZE);

    lcd.drawText(0, 30, "Switch on RX and device", MIDSIZE);

    #ifdef USE_BACKEND_BUS
    local bendcfg = config[CFG_Backend_Data][CFG_BEND_Bus];
    encoder(bendcfg[BEND_BUS_MixerGlobalVariable], 14, adr);
    #endif

    if (event == EVT_VIRTUAL_ENTER) then
      state[FSMADR_State] = FSMADR_STATE_Initial;
    end
  else
  end
end

local function displayAddressConfigColor(config, widget, encoder, pScaler, state, event, touch, buttonState)
  lcd.clear();

  if (config[CFG_Backend] == CFG_BEND_TipTip) or (config[CFG_Backend] == CFG_BEND_SolExpert) then
    lcd.drawText(widget[W_X], widget[W_Y], "Not usable with backend: " .. config[CFG_Backend], MIDSIZE + COLOR_THEME_WARNING);
    return;
  end

  processTrimsSelect(config, buttonState, function()
    TRACE("selectCB");
    event = EVT_VIRTUAL_ENTER;
  end);

  local bh = 2 * widget[W_FontHLarge];
  local border_h = 20;
  local bw = widget[W_Width] - 2 * border_h;;

  local rect = {xmin = widget[W_X] + border_h, xmax = widget[W_X] + bw,
    ymin = widget[W_Y] + widget[W_Height] / 2 - bh / 2, ymax = widget[W_Y] + widget[W_Height] / 2 + bh / 2};

  if (state[FSMADR_State] == FSMADR_STATE_Initial) then

    lcd.drawText(widget[W_X] + border_h, widget[W_Y] + widget[W_FontHLarge], "Attach only one device to the RX.", SMLSIZE + COLOR_THEME_PRIMARY1);

    lcd.drawFilledRectangle(rect.xmin, rect.ymin, rect.xmax - rect.xmin + 1, rect.ymax - rect.ymin + 1, COLOR_THEME_FOCUS);
    lcd.drawText(rect.xmin + 5, rect.ymin + 5, "Press [Enter] to start learning", MIDSIZE + COLOR_THEME_PRIMARY1);
    if (event == EVT_VIRTUAL_ENTER) then
      state[FSMADR_State] = FSMADR_STATE_Output;
    end
  elseif (state[FSMADR_State] == FSMADR_STATE_Output) then    
    local adr = pScaler(config) + 1;
    if (adr > 8) then
      adr = 8;
    end 

    lcd.drawText(widget[W_X] + border_h, widget[W_Y] + widget[W_FontHLarge], "Address: " .. adr, MIDSIZE + COLOR_THEME_WARNING);

    lcd.drawText(widget[W_X] + border_h, widget[W_Y] + widget[W_Height] - widget[W_FontHLarge], "Watch for the device to respond.", SMLSIZE + COLOR_THEME_PRIMARY1);

    lcd.drawFilledRectangle(rect.xmin, rect.ymin, rect.xmax - rect.xmin + 1, rect.ymax - rect.ymin + 1, COLOR_THEME_ACTIVE);
    lcd.drawText(rect.xmin + 5, rect.ymin + 5, "Switch on RX and device", MIDSIZE + COLOR_THEME_PRIMARY2);

    #ifdef USE_BACKEND_BUS
    local bendcfg = config[CFG_Backend_Data][CFG_BEND_Bus];
    encoder(bendcfg[BEND_BUS_MixerGlobalVariable], 14, adr);
    #endif

    if (event == EVT_VIRTUAL_ENTER) then
      state[FSMADR_State] = FSMADR_STATE_Initial;
    end
  else
  end
end

local function displayAddressConfigColorNoTheme(config, widget, encoder, pScaler, state, event, touch, buttonState)
  lcd.clear();

  if (config[CFG_Backend] == CFG_BEND_TipTip) or (config[CFG_Backend] == CFG_BEND_SolExpert) then
    lcd.drawText(widget[W_X], widget[W_Y], "Not usable with backend: " .. config[CFG_Backend], MIDSIZE);
    return;
  end

  processTrimsSelect(config, buttonState, function()
    event = EVT_VIRTUAL_ENTER;
  end);

  local bh = 2 * widget[W_FontHLarge];
  local border_h = 20;
  local bw = widget[W_Width] - 2 * border_h;;

  local rect = {xmin = widget[W_X] + border_h, xmax = widget[W_X] + bw,
    ymin = widget[W_Y] + widget[W_Height] / 2 - bh / 2, ymax = widget[W_Y] + widget[W_Height] / 2 + bh / 2};

  if (state[FSMADR_State] == FSMADR_STATE_Initial) then

    lcd.drawText(widget[W_X] + border_h, widget[W_Y] + widget[W_FontHLarge], "Attach only one device to the RX.", SMLSIZE);

    lcd.drawFilledRectangle(rect.xmin, rect.ymin, rect.xmax - rect.xmin + 1, rect.ymax - rect.ymin + 1);
    lcd.drawText(rect.xmin + 5, rect.ymin + 5, "Press [Enter] to start learning", MIDSIZE);

    if (event == EVT_VIRTUAL_ENTER) then
      state[FSMADR_State] = FSMADR_STATE_Output;
    end
  elseif (state[FSMADR_State] == FSMADR_STATE_Output) then    
    local adr = pScaler(config) + 1;
    if (adr > 8) then
      adr = 8;
    end 

    lcd.drawText(widget[W_X] + border_h, widget[W_Y] + widget[W_FontHLarge], "Address: " .. adr, MIDSIZE);

    lcd.drawText(widget[W_X] + border_h, widget[W_Y] + widget[W_Height] - widget[W_FontHLarge], "Watch for the device to respond.", SMLSIZE);

    lcd.drawFilledRectangle(rect.xmin, rect.ymin, rect.xmax - rect.xmin + 1, rect.ymax - rect.ymin + 1);
    lcd.drawText(rect.xmin + 5, rect.ymin + 5, "Switch on RX and device", MIDSIZE);

    #ifdef USE_BACKEND_BUS
    local bendcfg = config[CFG_Backend_Data][CFG_BEND_Bus];
    encoder(bendcfg[BEND_BUS_MixerGlobalVariable], 14, adr);
    #endif

    if (event == EVT_VIRTUAL_ENTER) then
      state[FSMADR_State] = FSMADR_STATE_Initial;
    end
  else
  end
end

local function processEventsBW()
end 

if (EVT_VIRTUAL_INC == EVT_VIRTUAL_NEXT) then
  processEventsBW = processEventsBWScroll;
else  
  processEventsBW = processEventsBWKeys;
end

if (LCD_W <= 128) then
  return {  
    displayMenu = displayMenuBW,
    displayParamMenu = displayParamMenuBW,
    processEvents = processEventsBW,
    processShortCuts = processShortCuts,
    processOverlays = processOverlays,
    selectItem = selectItem,
    selectParamItem = selectParamItem,
    processForeignInput = processForeignInput,
    displayAddressConfig = displayAddressConfigBW,
  };
elseif (LCD_W <= 212) then
  return { 
    displayMenu = displayMenuBW,
    displayParamMenu = displayParamMenuBW,
    processEvents = processEventsBW,
    processShortCuts = processShortCuts,
    processOverlays = processOverlays,
    selectItem = selectItem,
    selectParamItem = selectParamItem,
    processForeignInput = processForeignInput,
    displayAddressConfig = displayAddressConfigBW,
  };
else
  if (isEdgeTx()) then
    return { 
      isFullScreen = isFullScreen,
      updateWidgetDimensions = updateWidgetDimensionsEdgeTx,
      displayParamMenu = displayParamMenuColor,
      displayMenu = displayMenuColor,
      processEvents = processEventsColor,
      processShortCuts = processShortCuts,
      processOverlays = processOverlays,
      processTouch = processTouch,
      processButtons = processButtons,
      selectItem = selectItem,
      selectParamItem = selectParamItem,
      processForeignInput = processForeignInput,
      processRemoteInput = processRemoteInput,
      displayAddressConfig = displayAddressConfigColor,
      displayFmRssiWarning = displayFmRssiWarningColor,
    };
  else
    return { 
      isFullScreen = isFullScreen,
      updateWidgetDimensions = updateWidgetDimensionsOpenTx,
      displayParamMenu = displayParamMenuColorNoTheme,
      displayMenu = displayMenuColorNoTheme,
      processEvents = processEventsColor,
      processShortCuts = processShortCuts,
      processOverlays = processOverlays,
      processTouch = processTouch,
      processButtons = processButtons,
      selectItem = selectItem,
      selectParamItem = selectParamItem,
      processForeignInput = processForeignInput,
      processRemoteInput = processRemoteInput,
      displayAddressConfig = displayAddressConfigColorNoTheme,
      displayFmRssiWarning = displayFmRssiWarningColor,
    };
  end
end

